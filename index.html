<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Demo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
  <script src="lib/three.js"></script>
  <script src="src/customObj.js"></script>
  <script src="src/engine.js"></script>
</head>

<body>
  <script>

    var scene = new THREE.Scene();
    var clock = new THREE.Clock();
    var halfBandWidth = 1.4;
    var verticalwidth = 8.0;
    var flagLength = 1.4;
    var startYear = 1980; 
    var currentYear = 1980;
    var frequency = 0.25; // 1/4 year per second - one vertical width
    var speed = verticalwidth * frequency;
    const table = new YearData();
    const colorMaterial = new THREE.LineBasicMaterial( { color: 0x808080 } );

    //Add Grid
    {
      for(i = -5; i <= 5; i+=2){
        scene.add((new VerticalLine(halfBandWidth * i, colorMaterial)).getGeo());
      }
      for(i = 0; i <= 20;i++){
       scene.add((new HorizontalLine(verticalwidth * i, halfBandWidth *10, colorMaterial)).getGeo());
      }
    }

    const flagMesh = new Map();
    const countries = ['SovietUnion','DDR', 'Bulgaria', 'Cuba', 'Italy', 'America', 
    'Romania', 'Germany', 'CIS', 'France', 'Austrilia', 'UK','Japan', 'China', 
    'Canada', 'Korea', 'America', 'Russia', 'ROT'];
    countries.forEach(function(countryName){
      flagMesh.set(countryName, new CountryFlag(countryName));
    });
    var nodeMap = new Array();
    for(i = 1980; i <= 2020; i+=4){
      var indexYear = (i - 1980)/4;
      nodeMap[indexYear] = new Array(5);
      for(j = 1; j <= 5; ++j){
        nodeMap[indexYear][j-1] = new PathNode(j, i, table.getYearRank(i, j));
      }
    }

    //Static mesh
    for(i = 0; i <= 10; i++){
      for(j = 0;j < 5;j++){
        var node = nodeMap[i][j];
        var isReign = false;
        var prevPosX, prevPosZ;
        if(i>0){
          for(k=0; k < 5;k++){
            if(nodeMap[i-1][k].country == node.country){
              isReign = true;
              prevPosX = nodeMap[i-1][k].x;
              prevPosZ = nodeMap[i-1][k].z;
              break;
            }
          }
        }
        if(!isReign){
          node.mesh = flagMesh.get(node.country).createMesh();
          node.mesh.position.set(node.x, node.y, node.z);
        }else{
          node.mesh = (new ConnectedLine(node.x, node.z, prevPosX, prevPosZ, colorMaterial)).getGeo();          
        }
        scene.add(node.mesh);
      }
    }

    //canvas  
    var width = window.innerWidth; 
    var height = window.innerHeight;
    var k = width / height;
    //Camera
    var camera = new THREE.PerspectiveCamera(45, k, 1, 100);
    camera.position.set(0, 10, -15); //设置相机位置
    camera.lookAt(0, 2, 2); //设置相机方向(指向的场景对象)

    //Renderer
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(width, height);
    renderer.setClearColor(0x120205, 1);
    document.body.appendChild(renderer.domElement);
    
    var frontFive = new Array(5);
    function updateFrontFive(z){
      //Front Five
      var lerpWeight = Math.min((z % verticalwidth) / 7.0, 1.0);
      var indexYear = parseInt(z / verticalwidth);
      for(i = 0; i < 5;i++){
        var node = nodeMap[indexYear][i];
        node.mesh.visible = false;
        var isReign = false;
        var positionX;
        for(j = 0; j < 5; j++){
          if(node.country == nodeMap[indexYear+1][j].country){
            isReign = true;
            frontFive[i] = flagMesh.get(node.country).createMesh();
            positionX = (1 - lerpWeight) * node.x + lerpWeight *  nodeMap[indexYear+1][j].x;
            frontFive[i].position.set(positionX, 0.7, z);
            scene.add(frontFive[i]);
            break;
          }
        }
        if(!isReign){
            positionX = node.x;
            frontFive[i] = flagMesh.get(node.country).createMesh();
            frontFive[i].position.set(positionX, 0.7, z);
        }
        scene.add(frontFive[i]);
      }

    }

    var update = function(){
      camera.position.z += speed * clock.getDelta();
      camera.lookAt(0, 2, camera.position.z + 17);
      updateFrontFive(camera.position.z + 15);
      
    };

    var render = function(){
      renderer.render(scene, camera);
      for(i = 0; i < 5; i++){
        scene.remove(frontFive[i]);
      }
    };

    var GameLoop = function(){
      requestAnimationFrame(GameLoop);
      update();
      render();
    };
    GameLoop();

  </script>
</body>
</html>